from xml.dom.minidom import Document
import xml.dom.minidom
import os


class build_xml:
    def __init__(self):
        self.doc = Document()
        self.path = None
        self.file = None
        self.dir = None
        self.current_element = None  # 当前父节点
        self.name = []  # 储存当前父节点的栈 尾进尾出
        self.mark = 1

    def init_name(self, path):
        self.doc = Document()
        self.path = path
        self.file = None
        self.dir = None
        self.current_element = None  # 当前父节点
        self.name = []  # 储存当前父节点的栈 尾进尾出
        self.mark = 1

    # def bld_child_list(self, child_list, value_list, father=None, element_name=None):
    #     if not father and not element_name:
    #         print("err: no node")
    #     else:
    #         if not father and element_name:
    #             father = self.current_element.find(element_name)
    #         num = len(child_list)
    #         for i in range(num):
    #             object_child = self.doc.createElement(child_list[i])
    #             object_child_text = self.doc.createTextNode(value_list[i])
    #             object_child.appendChild(object_child_text)
    #             father.appendChild(object_child)

    # def bld_child(self, child, value, father=None, element_name=None):
    #     if not father and not element_name:
    #         print("err: no node")
    #         return 0
    #     else:
    #         if not father and element_name:
    #             father = self.find_father(element_name)
    #         object_child = self.doc.createElement(child)
    #         object_child_text = self.doc.createTextNode(value)
    #         object_child.appendChild(object_child_text)
    #         father.appendChild(object_child)

    # def find_father(self, name, value=None):
    #     list_c = self.current_element.childNodes
    #     list_node_n = []
    #     for i_name in list_c:
    #         if i_name.nodeName == name:
    #             list_node_n.append(i_name)
    #     num_node = len(list_node_n)

    #     if not value:
    #         if num_node == 0:
    #             print("no element is same to father")
    #             return None
    #         elif num_node == 1:
    #             return list_node_n[0]
    #         else:
    #             print("there a lot of name are same to father")
    #             print("only choose tne first")
    #             return list_node_n[0]
    #     else:
    #         if num_node == 0:
    #             print("no element is same to father")
    #             return None
    #         elif num_node == 1:
    #             if list_node_n[0].attributes == value:
    #                 return list_node_n[0]
    #             else:
    #                 print("no element is same to father")
    #                 return None
    #         else:
    #             for i in list_node_n:
    #                 if i.attributes == value:
    #                     return list_node_n[0]
    #             print("no element is same to father")
    #             return None

    def get_tree_name(self, list_tree):
        # 按照list_tree 递归式创建xml文件的父子标签 和子叶上的值
        list_len = len(list_tree)
        name = list_tree[0]
        if not self.name:
            self.name.append(self.doc)
        self.current_element = self.name[-1]
        # print(name)
        if list_len == 1:
            # 对子叶上数据单独处理
            object_child_text = self.doc.createTextNode(name)
            self.current_element.appendChild(object_child_text)
            self.name.pop()
            self.mark = 0
        else:
            for i in range(list_len):
                if i == 0:
                    object_child = self.doc.createElement(name)
                    self.current_element.appendChild(object_child)
                    self.name.append(object_child)
                if i > 0:
                    self.get_tree_name(list_tree[i])
                if i == list_len - 1:
                    # 每次便利完一个list之后 父节点前移一位，但子叶上的节点除外 否则会移两位
                    if self.mark:
                        self.name.pop()
                    self.mark += 1
                    pass

    def find_node(self, parent, name):
        child_list = parent.childNodes
        for i in child_list:
            a = i.nodeName
            b = i.nodeValue
            if self.deep == self.target_deep and a == '#text' and b == name:
                print(i.nodeName)
                self.target_list.append(i)
            elif i.nodeName != name:
                pass
            elif self.deep > self.target_deep:
                break
            else:
                self.deep += 1
                self.find_node(i, self.remove_list[self.deep])
        self.deep -= 1

    def romove_node(self, list, file_path, num):
        # 删除所有符合list的子节点 向上num个父节点的节点
        self.init_name(file_path)
        self.deep = 0
        self.target_deep = len(list) - 1
        self.target_list = []
        self.remove_list = list
        self.doc = xml.dom.minidom.parse(file_path)
        self.find_node(self.doc, self.remove_list[self.deep])
        if self.target_list:
            for a in self.target_list:
                for i in range(num):
                    a = a.parentNode
                parent = a.parentNode
                parent.removeChild(a)
        self.save_xml()

    def save_xml(self):
        f = open(self.path, 'w')
        self.doc.writexml(f, indent='', newl='', addindent='')
        f.close()


def build_xml0(folder, filename, path_jpg, path):
    # 按照list_tree 递归式创建xml文件
    xml0 = build_xml()
    list_tree = ["annotation",
                 ["folder", [folder]],
                 ["filename", [filename]],
                 ["path", [path_jpg]],
                 ["source", ["database", ["Unkonwn"]]],
                 ["size", ["width", ["1280"]], ["height", ["720"]], ["depth", ["3"]]],
                 ["segmented", ["0"]]
                 ]

    xml0.init_name(path)
    xml0.get_tree_name(list_tree)
    xml0.save_xml()


def main1():
    path_jpg_dir = "/home/pc/rospakage/src/cv_bridgepc/scripts/VOCdevkit/VOC2007/JPEGImages/"
    path_lable_dir = "/home/pc/rospakage/src/cv_bridgepc/scripts/VOCdevkit/VOC2007/Annotations/"
    jpg_folder = "JPEGImages"
    jpg_file_list = os.listdir(path_jpg_dir)
    for jpg_name in jpg_file_list:
        jpg_name_re = jpg_name[:-4]
        path_lable_file = path_lable_dir + jpg_name_re + '.xml'
        if not os.path.isfile(path_lable_file):
            # jpg对应的xml文件不存在 怎创建对应文件
            print(jpg_name)
            path_jpg = path_lable_dir + jpg_name
            build_xml0(jpg_folder, jpg_name, path_jpg, path_lable_file)


def main():
    path = "/home/pc/rospakage/src/cv_bridgepc/scripts/VOCdevkit/VOC2007/Annotations/photo1.xml"
    xml0 = build_xml()
    list0 = ["annotation", "object", "name", "person"]
    xml0.romove_node(list0, path, 2)


if __name__ == "__main__":
    main()
